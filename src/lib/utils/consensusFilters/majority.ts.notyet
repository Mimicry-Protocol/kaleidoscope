/**
 * Check to see if there is a majority of numbers that match each other
 * and return the majority value if there is one.
 *
 * If there are multiple sets of majority values, return all the values
 * that have a majority. If there is no majority, return the input array.
 *
 * For example:
 * [1n, 1n, 1n, 2n, 2n, 3n] would return [1n]
 * [1n, 1n, 2n, 2n, 3n] would return [1n, 2n]
 * [1n, 2n, 3n] would return [1n, 2n, 3n]
 *
 * @param values A list of BigInts
 * @returns A filtered list of BigInts
 */
export function majority(values: Array<bigint>): Array<bigint> {
    const majority = values.reduce((acc: any, curr) => {
      acc[curr.toString()] = (acc[curr.toString()] || 0) + 1;
      return acc;
    }, {});
  
    // Sort the keys by the number of times they appear in the array
    // Then create a set of the keys that appear the most often
    const mostCommon = new Set(
      Object.keys(majority)
        .sort((a, b) => majority[b] - majority[a])
        .filter((v, i, a) => majority[v] === majority[a[0]])
    );
  
    // Replace the values array with the set of most common values
    const filteredValues: bigint[] = Array.from(mostCommon).map((v) =>
      BigInt(v)
    );
  
    return filteredValues;
  }